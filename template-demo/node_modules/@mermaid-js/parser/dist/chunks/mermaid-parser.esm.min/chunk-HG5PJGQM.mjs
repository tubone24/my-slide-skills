import{E as u,L as f,M as T,O as S,a,b as l,c as p,d as m,e as c,f as v}from"./chunk-DQIAHSCC.mjs";var n=class extends S{static{a(this,"TreemapTokenBuilder")}constructor(){super(["treemap"])}};var C=/classDef\s+([A-Z_a-z]\w+)(?:\s+([^\n\r;]*))?;?/,s=class extends T{static{a(this,"TreemapValueConverter")}runCustomConverter(r,e,i){if(r.name==="NUMBER2")return parseFloat(e.replace(/,/g,""));if(r.name==="SEPARATOR")return e.substring(1,e.length-1);if(r.name==="STRING2")return e.substring(1,e.length-1);if(r.name==="INDENTATION")return e.length;if(r.name==="ClassDef"){if(typeof e!="string")return e;let t=C.exec(e);if(t)return{$type:"ClassDefStatement",className:t[1],styleText:t[2]||void 0}}}};function g(o){let r=o.validation.TreemapValidator,e=o.validation.ValidationRegistry;if(e){let i={Treemap:r.checkSingleRoot.bind(r)};e.register(i,r)}}a(g,"registerValidationChecks");var d=class{static{a(this,"TreemapValidator")}checkSingleRoot(r,e){let i;for(let t of r.TreemapRows)t.item&&(i===void 0&&t.indent===void 0?i=0:t.indent===void 0?e("error","Multiple root nodes are not allowed in a treemap.",{node:t,property:"item"}):i!==void 0&&i>=parseInt(t.indent,10)&&e("error","Multiple root nodes are not allowed in a treemap.",{node:t,property:"item"}))}};var y={parser:{TokenBuilder:a(()=>new n,"TokenBuilder"),ValueConverter:a(()=>new s,"ValueConverter")},validation:{TreemapValidator:a(()=>new d,"TreemapValidator")}};function B(o=c){let r=m(p(o),u),e=m(l({shared:r}),f,y);return r.ServiceRegistry.register(e),g(e),{shared:r,Treemap:e}}a(B,"createTreemapServices");export{y as a,B as b};
